(* ===================================================================== *)
(* === esxDOS support for the Next ===================================== *)
(* ===================================================================== *)

{$l esxdos.asm}

(* --------------------------------------------------------------------- *)
(* --- Interface to esxDOS --------------------------------------------- *)
(* --------------------------------------------------------------------- *)

type
  (**
   * Represents a standard set of Z80 registers. Used for moving values
   * into and out of esxDOS. Note that HL is always being used here
   * regardless of whether the program is a .dot or not.
   *)
  Registers = record
    AF, BC, DE, HL: Integer;
  end;

const
  (**
   * The last error that occurred during file IO. Most file functions will
   * be disabled as long as this value is non-zero.
   *)
  LastError: Byte = 0;

(**
 * Queries the last error that happened during an esxDOS call and resets
 * the value to zero, so that further esxDOS calls can be made.
 *)
function IOResult: Byte;
begin
  IOResult := LastError;
  LastError := 0;
end;

(**
 * Performs an esxDOS call. The R parameter is used for passing arguments
 * to the esxDOS call as well as getting results back. Note that HL is
 * always being used here regardless of whether the program is a .dot or
 * not.
 *)
function EsxDos(I: Integer; var R: Registers): Byte; register; external 'esx_call';

(**
 * Checks the last esxDOS error and terminates the program if it is <> 0.
 * Calls to this function are automatically generated by the compiler in
 * {$i+} mode.
 *)
procedure BDosThrow; (* -> Rename to CheckInOut *)
begin
  if LastError <> 0 then
  begin
    WriteLn('esxDOS error ', LastError);
    Halt;
  end;
end;

(* --------------------------------------------------------------------- *)
(* --- Internal implementation of "raw" untyped files ------------------ *)
(* --------------------------------------------------------------------- *)

type
  (**
   * Internally represents an untyped file. Is also used inside the interal
   * representations of typed files and text files. The name is the same as
   * for the CP/M implementation because higher-level file functions depend
   * on it. The size is 36 bytes, just like for CP/M, but that is more of a
   * coincidence.
   *)
  FileControlBlock = record
    Handle: Byte;                   (* esxDOS file handle, 0=file closed *)
    FileName: array[0..31] of Char; (* File name, 31 characters only     *)
    RL: Integer;                    (* Current record number low 16 bits *)
    RH: Byte;                       (* Current record number high 8 bits *)
  end;
  
procedure BlockAssign(var F: FileControlBlock; S: String);
var
  L: Byte;
begin
  if LastError <> 0 then Exit;

  with F do
  begin
    Handle := 0;
    L := Length(S);
    Move(S[1], FileName, L);
    FileName[L] := #0;
  end;
end;

procedure BlockErase(var F: FileControlBlock);
var
  R: Registers;
begin
  if LastError <> 0 then Exit;

  R.AF := Ord('*') shl 8;
  R.HL := Addr(F.FileName);

  LastError := EsxDos($ad, R);
end;

procedure BlockRename(var F: FileControlBlock; S: String);
var
  G: FileControlBlock;
  R: Registers;
begin
  if LastError <> 0 then Exit;

  BlockAssign(G, S);
  R.AF := Ord('*') shl 8;
  R.HL := Addr(F.FileName);
  R.DE := Addr(G.FileName);

  LastError := EsxDos($e0, R);
  if LastError = 0 then BlockAssign(F, S); (* TODO Can we rename open files? *)
end;

procedure BlockReset(var F: FileControlBlock);
var
  R: Registers;
begin
  if LastError <> 0 then Exit;

  R.AF := Ord('*') shl 8;
  R.HL := Addr(F.FileName);
  R.BC := $0300;

  LastError := EsxDos($9a, R);
  if LastError = 0 then
  begin
    F.Handle := R.AF shr 8;
    F.RL := 0;
  end;
end;

procedure BlockRewrite(var F: FileControlBlock);
var
  R: Registers;
begin
  if LastError <> 0 then Exit;

  R.AF := Ord('*') shl 8;
  R.HL := Addr(F.FileName);
  R.BC := $0f00;

  LastError := EsxDos($9a, R);
  if LastError = 0 then
  begin
    F.Handle := R.AF shr 8;
    F.RL := 0;
  end;
end;

procedure BlockClose(var F: FileControlBlock);
var
  R: Registers;
begin
  if LastError <> 0 then Exit;

  R.AF := F.Handle shl 8;

  LastError := EsxDos($9b, R);
  if LastError = 0 then F.Handle := 0;
end;

function BlockFilePos(var F: FileControlBlock): Integer;
begin
  BlockFilePos := F.RL;
end;

function BlockFileSize(var F: FileControlBlock): Integer;
var
  R: Registers;
  B: array[0..10] of Byte;
begin
  if LastError <> 0 then Exit;

  R.AF := F.Handle shl 8;
  R.HL := Addr(B);

  LastError := EsxDos($a1, R);
  BlockFileSize := (B[7] or (B[8] shl 8)) div 128;
end;

function BlockEof(var F: FileControlBlock): Boolean;
begin
  if LastError <> 0 then Exit;

  BlockEof := BlockFilePos(F) = BlockFileSize(F);
end;

procedure BlockSeek(var F: FileControlBlock; I: Integer);
var
  R: Registers;
begin
  if LastError <> 0 then Exit;

  F.RL := I;

  R.AF := F.Handle shl 8;
  R.BC := 0; (*I shr 9;*)
  R.DE := I * 128; (*shl 7;*)
  R.HL := 0;

  LastError := EsxDos($9f, R);
end;

procedure BlockBlockRead(var F: FileControlBlock; var Buffer; Count: Integer; var Actual: Integer);
var
  R: Registers;
begin
  if LastError <> 0 then Exit;

  R.HL := Addr(Buffer);
  Actual := 0;

  while Count > 0 do
  begin
    R.AF := F.Handle shl 8;
    R.BC := 128;

    LastError := EsxDos($9d, R);
    if LastError <> 0 then Exit;

    Inc(F.RL);
    Inc(Actual);
    Dec(Count);
  end;
end;

procedure BlockBlockWrite(var F: FileControlBlock; var Buffer; Count: Integer; var Actual: Integer);
var
  R: Registers;
begin
  if LastError <> 0 then Exit;

  R.HL := Addr(Buffer);
  Actual := 0;

  while Count > 0 do
  begin
    R.AF := F.Handle shl 8;
    R.BC := 128;

    LastError := EsxDos($9e, R);
    if LastError <> 0 then Exit;

    Inc(F.RL);
    Inc(Actual);
    Dec(Count);
  end;
end;