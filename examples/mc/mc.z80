; program mc.pas
CPM:            equ     1               ; Target is CP/M .com file
                include "/Users/joerg/projects/pl0/pl0.z80"
                jp      main
; [0] (* Built-ins that do not have to be defined in the compiler itself. *)
; [1] 
; [2] {$a+}
; [3] 
; [4] (* -------------------------------------------------------------------------- *)
; [5] (* --- String support ------------------------------------------------------- *)
; [6] (* -------------------------------------------------------------------------- *)
; [7] 
; [8] (* Built-in: procedure Val(S: String; var Scalar; var E: Integer); *)
; [9] (* Built-in: procedure Str(N: Scalar; var S: String);              *)
; [10] 
; [11] procedure Delete(var S: String; Start, Count: Integer);     external '__delete';
; [12] procedure Insert(S: String; var T: String; Start: Integer); external '__insert';
; [13] 
; [14] (* Built-in: function Concat(S: String, ...): String;              *)
; [15] 
; [16] function Copy(S: String; Start, Count: Integer): String;    external '__copy';
; [17] function Length(S: String): Integer;                        external '__length';
; [18] function Pos(S, T: String): Integer;                        external '__pos';
; [19] 
; [20] (* -------------------------------------------------------------------------- *)
; [21] (* --- Set support ---------------------------------------------------------- *)
; [22] (* -------------------------------------------------------------------------- *)
; [23] 
; [24] (* Built-in: procedure Include(var S: Set; E: Element);     *)
; [25] (* Built-in: procedure Exclude(var S: Set; E: Element);     *)
; [26] 
; [27] (* -------------------------------------------------------------------------- *)
; [28] (* --- File support --------------------------------------------------------- *)
; [29] (* -------------------------------------------------------------------------- *)
; [30] 
; [31] (* TBD *)
; [32] 
; [33] (* -------------------------------------------------------------------------- *)
; [34] (* --- Heap management ------------------------------------------------------ *)
; [35] (* -------------------------------------------------------------------------- *)
; [36] 
; [37] type
; [38]   PBlock = ^TBlock;
; [39]   TBlock = record
; [40]     Next: PBlock;
; [41]     Size: Integer;
; [42]   end;
; [43] 
; [44] var
; [45]   HeapPtr: PBlock absolute '__heapptr';
; [46] 
; [47] (* Built-in: procedure New(var P: Pointer);       *)
; [48] (* Built-in: procedure Dispose(P: Pointer);       *)
; [49] 
; [50] procedure FreeMem(P: Pointer; Size: Integer);     register; external '__freemem';
; [51] procedure GetMem(var P: Pointer; Size: Integer);  register; external '__getmem';
; [52] 
; [53] function MemAvail: Integer;
; [54] var
; [55]   P: PBlock;
global8:        ds      2               ; Global P
; [56]   I: Integer;
global9:        ds      2               ; Global I
; [57] begin
; var MemAvail(@RESULT), P(@global8), I(@global9)
__MemAvail7:    push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
; [58]   P := HeapPtr;
                push    hl
                ld      hl,global8 + 0
                push    hl
                ld      hl,(__heapptr + 0)
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [59]   I := 0;
                ld      hl,global9 + 0
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [60]   while P <> nil do
while11:
                ld      hl,(global8 + 0)
                ld      de,0            ; Literal 0
                call    __int16_neq
                ld      h,0
                ld      l,a
; [61]   begin
                bit     0,l
                jp      z,false12
; [62]     I := I + P^.Size;
                ld      hl,global9 + 0
                push    hl
                ld      hl,(global9 + 0)
                ex      de,hl
                push    de
                ld      hl,global8 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl \ inc hl     ; Literal 2
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [63]     P := P^.Next;
                ld      hl,global8 + 0
                push    hl
                ld      hl,global8 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [64]   end;
                jp      while11
false12:
; [65] 
; [66]   MemAvail := I;
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      hl,(global9 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [67] end;
exit10:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [68] 
; [69] function MaxAvail: Integer;
; [70] var
; [71]   P: PBlock;
global14:       ds      2               ; Global P
; [72]   I: Integer;
global15:       ds      2               ; Global I
; [73] begin
; var MaxAvail(@RESULT), P(@global14), I(@global15)
__MaxAvail13:   push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
; [74]   P := HeapPtr;
                push    hl
                ld      hl,global14 + 0
                push    hl
                ld      hl,(__heapptr + 0)
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [75]   I := 0;
                ld      hl,global15 + 0
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [76]   while P <> nil do
while17:
                ld      hl,(global14 + 0)
                ld      de,0            ; Literal 0
                call    __int16_neq
                ld      h,0
                ld      l,a
; [77]   begin
                bit     0,l
                jp      z,false18
; [78]     if P^.Size > I then I := P^.Size;
                ld      hl,global14 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl \ inc hl     ; Literal 2
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,(global15 + 0)
                pop     de
                call    __int16_lt
                and     a
                jp      z,false19
                ld      hl,global15 + 0
                push    hl
                ld      hl,global14 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl \ inc hl     ; Literal 2
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
false19:
; [79]     P := P^.Next;
                ld      hl,global14 + 0
                push    hl
                ld      hl,global14 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [80]   end;
                jp      while17
false18:
; [81] 
; [82]   MaxAvail := I;
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      hl,(global15 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [83] end;
exit16:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [84] 
; [85] procedure InitHeap;
; [86] var
; [87]   EofMarker: Integer absolute 'eof';
; [88]   HeapStart, HeapBytes: Integer;
global21:       ds      2               ; Global HeapStart
global22:       ds      2               ; Global HeapBytes
; [89] begin
; var EofMarker(@eof), HeapStart(@global21), HeapBytes(@global22)
__InitHeap20:   push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
                push    hl
; [90]   HeapStart := Addr(EofMarker);
                push    hl
                ld      hl,global21 + 0
                push    hl
                ld      hl,eof + 0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [91]   if (HeapStart >= 0) and (HeapStart < 24576) then HeapStart := 24576;
                ld      hl,(global21 + 0)
                ld      de,0            ; Literal 0
                call    __int16_geq
                ld      h,0
                ld      l,a
                push    hl
                ld      hl,(global21 + 0)
                ld      de,24576        ; Literal 24576
                call    __int16_lt
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      a,l
                and     e
                ld      l,a
                bit     0,l
                jp      z,false24
                ld      hl,global21 + 0
                ld      de,24576
                ld      (hl),e \ inc hl \ ld (hl),d
false24:
; [92]   HeapBytes := 57343 - HeapStart;
                ld      hl,global22 + 0
                push    hl
                ld      de,57343        ; Literal 57343
                push    de
                ld      hl,(global21 + 0)
                ex      de,hl
                pop     hl
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [93]   HeapPtr := nil;
                ld      hl,__heapptr + 0
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [94] 
; [95]   if HeapBytes > 0 then
                ld      hl,(global22 + 0)
                ex      de,hl
                push    de
                ld      hl,0            ; Literal 0
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
; [96]     FreeMem(Ptr(HeapStart), HeapBytes);
                bit     0,l
                jp      z,false25
                ld      hl,(global21 + 0)
                ex      de,hl
                push    de
                ld      hl,(global22 + 0)
                ex      de,hl
                pop     hl
                call    __freemem
false25:
; [97] end;
exit23:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [98] 
; [99] (* -------------------------------------------------------------------------- *)
; [100] (* --- Standard procedures -------------------------------------------------- *)
; [101] (* -------------------------------------------------------------------------- *)
; [102] 
; [103] (* Built-in: procedure Break;                   *)
; [104] (* Built-in: procedure Continue;                *)
; [105] (* Built-in: procedure Exit;                    *)
; [106] 
; [107] const
; [108]   Black   = 0;
; [109]   Blue    = 1;
; [110]   Red     = 2;
; [111]   Magenta = 3;
; [112]   Green   = 4;
; [113]   Cyan    = 5;
; [114]   Yellow  = 6;
; [115]   White   = 7;
; [116] 
; [117] procedure ClrScr; register;                 external '__clrscr';
; [118] procedure GotoXY(X, Y: Integer); register;  external '__gotoxy';
; [119] procedure CursorOn; register;               external '__cursor_on';
; [120] procedure CursorOff; register;              external '__cursor_off';
; [121] 
; [122] procedure ConOut(C: Char); register;        external '__conout';
; [123] 
; [124] procedure ClrEol; register; inline
__ClrEol31:
; [125] (
; [126]   $2e /                       (* ld   l,27      *)
                db      46
; [127]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [128]   $3e / 'K' /                 (* ld   l,'K'     *)
                db      62,75
; [129]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [130]   $c9                         (* ret            *)
; [131] );
                db      201
                ret
; [132] 
; [133] procedure ClrEos; register; inline
__ClrEos32:
; [134] (
; [135]   $2e /                       (* ld   l,27      *)
                db      46
; [136]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [137]   $3e / 'J' /                 (* ld   l,'J'     *)
                db      62,74
; [138]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [139]   $c9                         (* ret            *)
; [140] );
                db      201
                ret
; [141] 
; [142] procedure InsLine; register; inline
__InsLine33:
; [143] (
; [144]   $2e /                       (* ld   l,27      *)
                db      46
; [145]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [146]   $3e / 'L' /                 (* ld   l,'L'     *)
                db      62,76
; [147]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [148]   $c9                         (* ret            *)
; [149] );
                db      201
                ret
; [150] 
; [151] procedure DelLine; register; inline
__DelLine34:
; [152] (
; [153]   $2e /                       (* ld   l,27      *)
                db      46
; [154]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [155]   $3e / 'M' /                 (* ld   l,'M'     *)
                db      62,77
; [156]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [157]   $c9                         (* ret            *)
; [158] );
                db      201
                ret
; [159] 
; [160] procedure TextColor(I: Integer); register;      external '__textfg';
; [161] procedure TextBackground(I: Integer); register; external '__textbg';
; [162] 
; [163] (* -------------------------------------------------------------------------- *)
; [164] (* --- Arithmetic functions ------------------------------------------------- *)
; [165] (* -------------------------------------------------------------------------- *)
; [166] 
; [167] const
; [168]   MaxInt = 32767;
; [169]   MinInt = -32768;
; [170] 
; [171] (* Built-in: function Abs(I: Integer): Integer  *)
; [172] (* Built-in: function Abs(R: Real): Real        *)
; [173] 
; [174] function ArcTan(R: Real): Real; register; external 'ATN';
; [175] function Cos(R: Real): Real; register;    external 'COS';
; [176] function Exp(R: Real): Real; register;    external 'EXP';
; [177] function Frac(R: Real): Real; register;   external 'FRAC';
; [178] function Int(R: Real): Real; register;    external 'INT';
; [179] function Ln(R: Real): Real; register;     external 'LN';
; [180] function Log(R: Real): Real; register;    external 'LOG';
; [181] function Sin(R: Real): Real; register;    external 'SIN';
; [182] function Sqr(R: Real): Real; register;    external '__fltpwr2';
; [183] function Sqrt(R: Real): Real; register;   external 'SQR';
; [184] function Tan(R: Real): Real; register;    external 'TAN';
; [185] 
; [186] function Pi: Real; register;              external 'ACPI';
; [187] 
; [188] function MaxReal: Real; register; inline
__MaxReal49:
; [189] (
; [190]   $01 / $7FFF /
                db      1
                dw      32767
; [191]   $11 / $FFFF /
                db      17
                dw      65535
; [192]   $21 / $FFFF /
                db      33
                dw      65535
; [193]   $c9
; [194] );
                db      201
                ret
; [195] 
; [196] function MinReal: Real; register; inline
__MinReal50:
; [197] (
; [198]   $01 / $FFFF /
                db      1
                dw      65535
; [199]   $11 / $FFFF /
                db      17
                dw      65535
; [200]   $21 / $FFFF /
                db      33
                dw      65535
; [201]   $c9
; [202] );
                db      201
                ret
; [203] 
; [204] (* -------------------------------------------------------------------------- *)
; [205] (* --- Scalar functions ----------------------------------------------------- *)
; [206] (* -------------------------------------------------------------------------- *)
; [207] 
; [208] (* Built-in: function Pred(Ordinal): Ordinal;     *)
; [209] (* Built-in: function Succ(Ordinal): Ordinal;     *)
; [210] (* Built-in: function Odd(Ordinal): Boolean;      *)
; [211] (* Built-in: function Even(Ordinal): Boolean;     *)
; [212] 
; [213] (* -------------------------------------------------------------------------- *)
; [214] (* --- Transfer functions --------------------------------------------------- *)
; [215] (* -------------------------------------------------------------------------- *)
; [216] 
; [217] (* Built-in: function Ord(Ordinal): Integer;      *)
; [218] 
; [219] function Round(R: Real): Integer; register; external '__fltrnd';
; [220] function Trunc(R: Real): Integer; register; external 'FIX';
; [221] 
; [222] function Chr(B: Byte): Char; register; inline
__Chr53:
; [223] (
; [224]   $c9         (* ret          *)
; [225] );
                db      201
                ret
; [226] 
; [227] (* -------------------------------------------------------------------------- *)
; [228] (* --- Miscellaneous standard functions ------------------------------------- *)
; [229] (* -------------------------------------------------------------------------- *)
; [230] 
; [231] (* Built-in: function KeyPressed: Boolean;        *)
; [232] (* Built-in: function SizeOf(XYZ): Integer;       *)
; [233] (* Built-in: function Addr(XYZ): Integer;         *)
; [234] (* Built-in: function Ptr(I: Integer): Pointer;   *)
; [235] 
; [236] function Hi(I: Integer): Byte; register; inline
__Hi54:
; [237] (
; [238]   $6c /       (* ld   l,h     *)
                db      108
; [239]   $26 / $00 / (* ld   h,0     *)
                db      38,0
; [240]   $c9         (* ret          *)
; [241] );
                db      201
                ret
; [242] 
; [243] function Lo(I: Integer): Byte; register; inline
__Lo55:
; [244] (
; [245]   $26 / $00 / (* ld   h,0     *)
                db      38,0
; [246]   $c9         (* ret          *)
; [247] );
                db      201
                ret
; [248] 
; [249] function Swap(I: Integer): Integer; register; inline
__Swap56:
; [250] (
; [251]   $7c /       (* ld   a,h     *)
                db      124
; [252]   $65 /       (* ld   h,l     *)
                db      101
; [253]   $6f /       (* ld   l,a     *)
                db      111
; [254]   $c9         (* ret          *)
; [255] );
                db      201
                ret
; [256] 
; [257] function UpCase(C: Char): Char; register; inline
__UpCase57:
; [258] (
; [259]   $7d /       (* ld   a,l     *)
                db      125
; [260]   $fe / $61 / (* cp   'a'     *)
                db      254,97
; [261]   $d8 /       (* ret  c       *)
                db      216
; [262]   $fe / $7b / (* cp   'z' + 1 *)
                db      254,123
; [263]   $d0 /       (* ret  nc      *)
                db      208
; [264]   $cb / $ad / (* res  4,l     *)
                db      203,173
; [265]   $c9         (* ret          *)
; [266] );
                db      201
                ret
; [267] 
; [268] function LoCase(C: Char): Char; register; inline
__LoCase58:
; [269] (
; [270]   $7d /       (* ld   a,l     *)
                db      125
; [271]   $fe / $41 / (* cp   'A'     *)
                db      254,65
; [272]   $d8 /       (* ret  c       *)
                db      216
; [273]   $fe / $5b / (* cp   'Z' + 1 *)
                db      254,91
; [274]   $d0 /       (* ret  nc      *)
                db      208
; [275]   $cb / $ed / (* set  4,l     *)
                db      203,237
; [276]   $c9         (* ret          *)
; [277] );
                db      201
                ret
; [278] 
; [279] var
; [280]   CmdLine: String absolute $80;
; [281] 
; [282] function ParamCount: Byte;
; [283] var
; [284]   C, D: Boolean;
global60:       ds      1               ; Global C
global61:       ds      1               ; Global D
; [285]   I, J: Byte;
global62:       ds      1               ; Global I
global63:       ds      1               ; Global J
; [286] begin
; var ParamCount(@RESULT), C(@global60), D(@global61), I(@global62), J(@global63)
__ParamCount59: push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
                push    hl
                push    hl
; [287]   C := True;
                push    hl
                ld      hl,global60 + 0
                ld      de,1
                ld      (hl),e
; [288]   J := 0;
                ld      hl,global63 + 0
                ld      de,0
                ld      (hl),e
; [289] 
; [290]   for I := 1 to Length(CmdLine) do
                ld      hl,global62     ; Get global I
                ld      de,1
                ld      (hl),e
                push    hl
                ld      hl,128 + 0
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      hl,global62     ; Get global I
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak66
forloop65:
; [291]   begin
; [292]     D := CmdLine[I] > ' ';
                ld      hl,global61 + 0
                push    hl
                ld      hl,128 + 0
                push    hl
                ld      hl,global62 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,32           ; Literal 32
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [293]     if not C and D then Inc(J);
                ld      hl,global60 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      a,1
                xor     l
                ld      l,a
                push    hl
                ld      hl,global61 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      a,l
                and     e
                ld      l,a
                bit     0,l
                jp      z,false68
                ld      hl,global63 + 0
                inc     (hl)
false68:
; [294]     C := D;
                ld      hl,global60 + 0
                push    hl
                ld      hl,global61 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [295]   end;
fornext67:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,global62     ; Get global I
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak66
                ld      hl,global62     ; Get global I
                inc     (hl)
                jp      forloop65
forbreak66:     pop     de              ; Cleanup limit
; [296] 
; [297]   ParamCount := J;
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      hl,global63 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [298] end;
exit64:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [299] 
; [300] function ParamStr(I: Byte): String;
; [301] var
; [302]   C, D: Boolean;
global70:       ds      1               ; Global C
global71:       ds      1               ; Global D
; [303]   J, K: Byte;
global72:       ds      1               ; Global J
global73:       ds      1               ; Global K
; [304] begin
; var ParamStr(@RESULT), I(+6), C(@global70), D(@global71), J(@global72), K(@global73)
__ParamStr69:   push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
                push    hl
                push    hl
; [305]   C := True;
                push    hl
                ld      hl,global70 + 0
                ld      de,1
                ld      (hl),e
; [306]   K := 1;
                ld      hl,global73 + 0
                ld      de,1
                ld      (hl),e
; [307] 
; [308]   for J := 1 to Length(CmdLine) do
                ld      hl,global72     ; Get global J
                ld      de,1
                ld      (hl),e
                push    hl
                ld      hl,128 + 0
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      hl,global72     ; Get global J
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak76
forloop75:
; [309]   begin
; [310]     D := CmdLine[J] > ' ';
                ld      hl,global71 + 0
                push    hl
                ld      hl,128 + 0
                push    hl
                ld      hl,global72 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,32           ; Literal 32
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [311] 
; [312]     if not C and D then
                ld      hl,global70 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      a,1
                xor     l
                ld      l,a
                push    hl
                ld      hl,global71 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      a,l
                and     e
                ld      l,a
; [313]       K := J
                bit     0,l
                jp      z,false78
                ld      hl,global73 + 0
; [314]     else if C and not D then
                push    hl
                ld      hl,global72 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
                jp      endif79
false78:
                ld      hl,global70 + 0
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,global71 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      a,1
                xor     l
                ld      l,a
                ex      de,hl
                pop     hl
                ld      a,l
                and     e
                ld      l,a
; [315]     begin
                bit     0,l
                jp      z,false80
; [316]       if I = 0 then
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_eq
                ld      h,0
                ld      l,a
; [317]       begin
                bit     0,l
                jp      z,false81
; [318]         Dec(J);
                ld      hl,global72 + 0
                dec     (hl)
; [319]         Break;
                jp      forbreak76      ; Break
; [320]       end;
false81:
; [321] 
; [322]       Dec(I);
                ld      de,ix
                ld      hl,6
                add     hl,de
                dec     (hl)
; [323]     end;
false80:
endif79:
; [324] 
; [325]     C := D;
                ld      hl,global70 + 0
                push    hl
                ld      hl,global71 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [326]   end;
fornext77:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,global72     ; Get global J
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak76
                ld      hl,global72     ; Get global J
                inc     (hl)
                jp      forloop75
forbreak76:     pop     de              ; Cleanup limit
; [327] 
; [328]   if I = 0 then
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_eq
                ld      h,0
                ld      l,a
; [329]     ParamStr := Copy(CmdLine, K, J - K + 1)
                bit     0,l
                jp      z,false82
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                call    __mkstr
                ld      hl,128 + 0
                call    __loadstr
                ld      hl,global73 + 0
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,global72 + 0
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,global73 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                inc     hl
; [330]   else
                push    hl
                call    __copy
; Post call cleanup 260 bytes
                ld      hl,260          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      a,255
                call    __storestr
                jp      endif83
false82:
; [331]     ParamStr := '';
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      hl,string84
                pop     de
                ld      a,255
                call    __movestr
endif83:
; [332] end;
exit74:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [333] 
; [334] var
; [335]   RandSeed1: Integer absolute 'seed1';
; [336]   RandSeed2: Integer absolute 'seed2';
; [337] 
; [338] function Random(Range: Integer): Integer; register; external '__random';
; [339] function RandomReal: Real; register;                external '__random48';
; [340] 
; [341] procedure Randomize; register; inline
__Randomize87:
; [342] (
; [343]   $ed / $5f /             (* ld   a,r             *)
                db      237,95
; [344]   $2a / RandSeed1 /       (* ld   hl,(RandSeed1)  *)
                db      42
                dw      seed1
; [345]   $ed / $5b / RandSeed2 / (* ld   de,(RandSeed2)  *)
                db      237,91
                dw      seed2
; [346]   $53 /                   (* ld   d,e             *)
                db      83
; [347]   $5c /                   (* ld   e,h             *)
                db      92
; [348]   $65 /                   (* ld   h,l             *)
                db      101
; [349]   $6f /                   (* ld   l,a             *)
                db      111
; [350]   $22 / RandSeed1 /       (* ld   (RandSeed1),hl  *)
                db      34
                dw      seed1
; [351]   $ed / $53 / RandSeed2 / (* ld   (RandSeed2),de  *)
                db      237,83
                dw      seed2
; [352]   $c9                     (* ret                  *)
; [353] );
                db      201
                ret
; [354] 
; [355] procedure CheckBreak; register; external '__checkbreak';
; [356] 
; [357] (* Built-in: procedure FillChar(var Dest; Length: Integer; Data); *)
; [358] 
; [359] procedure Move(var Source, Dest; Count: Integer); register; external '__move';
; [360] 
; [361] (* Built-in: procedure Halt([ExitCode: Byte]) *)
; [362] 
; [363] procedure Delay(MS: Integer);
; [364] var
; [365]   A: Byte;
global91:       ds      1               ; Global A
; [366] begin
; var MS(+6), A(@global91)
__Delay90:      push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [367]   A := BDos(141, MS div 20);
                push    hl
                ld      hl,global91 + 0
                push    hl
                ld      de,141          ; Literal 141
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,20           ; Literal 20
                call    __sdiv16        ; Div
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e
; [368] end;
exit92:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [369] 
; [370] function KeyPressed: Boolean;
; [371] begin
; var KeyPressed(@RESULT)
__KeyPressed93: push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [372]   KeyPressed := BDOS(11, 0) <> 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      hl,11           ; Literal 11
                ld      de,0            ; Literal 0
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,0
                call    __int16_neq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [373] end;
exit94:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [374] 
; [375] function ReadKey: CHar;
; [376] begin
; var ReadKey(@RESULT)
__ReadKey95:    push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [377]   repeat until KeyPressed;
repeat97:
                ld      de,0            ; Literal 0
                push    de
                call    __KeyPressed93
                pop     hl
                bit     0,l
                jp      z,repeat97
break98:
; [378]   ReadKey := Chr(BDOS(6, 255));
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      hl,6            ; Literal 6
                ld      de,255          ; Literal 255
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                call    __Chr53
                ex      de,hl
                pop     hl
                ld      (hl),e
; [379] end;
exit96:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [380] 
; [381] (* -------------------------------------------------------------------------- *)
; [382] (* --- Assertion support ---------------------------------------------------- *)
; [383] (* -------------------------------------------------------------------------- *)
; [384] 
; [385] (* Built-in: procedure Assert(B: Boolean); *)
; [386] 
; [387] var
; [388]   AssertPassed: Integer absolute '__assertpassed';
; [389]   AssertFailed: Integer absolute '__assertfailed';
; [390] 
; [391] (* -------------------------------------------------------------------------- *)
; [392] (* --- CP/M 2.2 low-level file support -------------------------------------- *)
; [393] (* -------------------------------------------------------------------------- *)
; [394] 
; [395] type
; [396]   FileControlBlock = record             (* CP/M file control block            *)
; [397]     DR: Byte;                           (* Drive number                       *)
; [398]     FN: array[0..7] of Char;            (* File name, 8 chars, space-padded   *)
; [399]     TN: array[0..2] of Char;            (* Extension, 3 chars, space-padded   *)
; [400]     EX, S1, S2, RC: Byte;               (* CP/M internal stuff                *)
; [401]     AL: array[0..15] of Byte;           (* CP/M internal stuff                *)
; [402]     CR: Byte;                           (* CP/M internal stuff                *)
; [403]     RL: Integer; RH: Byte;              (* 24 bit random record number        *)
; [404]   end;
; [405] 
; [406]   TextRec = record                      (* Internal text file representation  *)
; [407]     FCB: FileControlBlock;              (* FCB, *must* start at offset 0      *)
; [408]     Readable: Boolean;                  (* File is open for reading           *)
; [409]     Writable: Boolean;                  (* File is open for writing           *)
; [410]     Offset: Integer;                    (* Offset within 128 byte buffer      *)
; [411]     DMA: array[0..127] of Char;         (* Internal sector buffer             *)
; [412]   end;
; [413] 
; [414]   FileRec = record                      (* Internal typed file representation *)
; [415]     FCB: FileControlBlock;              (* FCB, *must* start at offset 0      *)
; [416]     CompSize: Integer;                  (* Size of component type             *)
; [417]     CompCount: Integer;                 (* Number of components in file       *)
; [418]     CompIndex: Integer;                 (* Index of current component         *)
; [419]     Offset: Integer;                    (* Offset within 128 byte buffer      *)
; [420]     Modified: Boolean;                  (* Current record has been modified   *)
; [421]     case Boolean of
; [422]       False: (DMA: array[0..127] of Char;); (* Internal sector buffer         *)
; [423]       True:  (HdrCount, HdrSize: Integer;); (* Typed file header              *)
; [424]   end;
; [425] 
; [426] (* --- Untyped file routines, use FileControlBlock as representation -------- *)
; [427] 
; [428] const
; [429]   LastError: Byte = 0;
const99:
                db      0
; [430] 
; [431] function IOResult: Byte;
; [432] begin
; var IOResult(@RESULT)
__IOResult100:  push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [433]   IOResult := LastError;
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [434]   LastError := 0;
                ld      hl,const99 + 0
                ld      de,0
                ld      (hl),e
; [435] end;
exit101:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [436] 
; [437] procedure BDosCatch(Func: Byte; Param: Integer);
; [438] var
; [439]   A: Byte;
global103:      ds      1               ; Global A
; [440] begin
; var Func(+8), Param(+6), A(@global103)
__BDosCatch102: push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [441]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false105
                jp      exit104         ; Exit
false105:
; [442]   A := BDos(Func, Param);
                ld      hl,global103 + 0
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e
; [443]   (* WriteLn('BDos(', Func, ') returned A=' , A); *)
; [444]   if A = 255 then LastError := 1;
                ld      hl,global103 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,255          ; Literal 255
                call    __int16_eq
                and     a
                jp      z,false106
                ld      hl,const99 + 0
                ld      de,1
                ld      (hl),e
false106:
; [445] end;
exit104:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [446] 
; [447] procedure BDosThrow;
; [448] begin
__BDosThrow107: push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [449]   if LastError <> 0 then
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                ld      h,0
                ld      l,a
; [450]   begin
                bit     0,l
                jp      z,false109
; [451]     WriteLn('BDos error');
                ld      hl,string110
                call    __puts
                call    __newline
; [452]     Halt;
                jp      __done
; [453]   end;
false109:
; [454] end;
exit108:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [455] 
; [456] procedure BlockAssign(var F: FileControlBlock; S: String);
; [457] var
; [458]   I, L, P, Q: Integer;
global112:      ds      2               ; Global I
global113:      ds      2               ; Global L
global114:      ds      2               ; Global P
global115:      ds      2               ; Global Q
; [459] begin
; var F(+262), S(+6), I(@global112), L(@global113), P(@global114), Q(@global115)
__BlockAssign111:push    ix             ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
                push    hl
                push    hl
; [460]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false117
                jp      exit116         ; Exit
false117:
; [461] 
; [462]   with F do
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [463]   begin
; [464]     L := Length(S);
                push    de
                ld      hl,global113 + 0
                push    hl
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [465] 
; [466]     if (L > 1) and (S[2] = ':') then
                ld      hl,(global113 + 0)
                ex      de,hl
                push    de
                ld      hl,1            ; Literal 1
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                inc     hl \ inc hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,58           ; Literal 58
                call    __int16_eq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      a,l
                and     e
                ld      l,a
; [467]     begin
                bit     0,l
                jp      z,false118
; [468]       DR := Ord(UpCase(S[1])) - 64;
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                inc     hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __UpCase57
                ld      de,64
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e
; [469]       Delete(S, 1, 2);
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      de,2            ; Literal 2
                push    de
                call    __delete
; Post call cleanup 6 bytes
                pop     hl
                pop     hl
                pop     hl
; [470]       Dec(L, 2);
                ld      hl,global113 + 0
                push    hl
                ld      bc,2            ; Literal 2
                pop     hl
                call    __dec16by
; [471]     end
; [472]     else DR := 0;
                jp      endif119
false118:
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                ld      (hl),e
endif119:
; [473] 
; [474]     P := Pos('.', S);
                ld      hl,global114 + 0
                push    hl
                push    hl
                ld      de,46           ; Literal 46
                call    __char2str
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    __pos
; Post call cleanup 512 bytes
                ld      hl,512          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [475]     if P = 0 then P := L + 1;
                ld      hl,(global114 + 0)
                ld      de,0            ; Literal 0
                call    __int16_eq
                and     a
                jp      z,false120
                ld      hl,global114 + 0
                push    hl
                ld      hl,(global113 + 0)
                inc     hl              ; Literal 1
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
false120:
; [476] 
; [477]     Q := P - 1;
                ld      hl,global115 + 0
                push    hl
                ld      hl,(global114 + 0)
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [478]     if Q > 8 then Q := 8;
                ld      hl,(global115 + 0)
                ex      de,hl
                push    de
                ld      hl,8            ; Literal 8
                pop     de
                call    __int16_lt
                and     a
                jp      z,false121
                ld      hl,global115 + 0
                ld      de,8
                ld      (hl),e \ inc hl \ ld (hl),d
false121:
; [479] 
; [480]     for I := 1 to Q do FN[I - 1] := UpCase(S[I]);
                ld      hl,global112    ; Get global I
                ld      de,1
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      hl,(global115 + 0)
                ex      de,hl
                push    de
                push    de
                ld      hl,(global112)  ; Get global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak123
forloop122:
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                inc     hl
                push    hl
                ld      hl,(global112 + 0)
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      hl,(global112 + 0)
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __UpCase57
                ex      de,hl
                pop     hl
                ld      (hl),e
fornext124:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global112)  ; Get global I
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak123
                ld      hl,global112    ; Get global I
                call    __inc16
                jp      forloop122
forbreak123:    pop     de              ; Cleanup limit
; [481]     for I := Q + 1 to 8 do FN[I - 1] := ' ';
                ld      hl,global112    ; Get global I
                push    hl
                ld      hl,(global115 + 0)
                inc     hl              ; Literal 1
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      de,8            ; Literal 8
                push    de
                push    de
                ld      hl,(global112)  ; Get global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak126
forloop125:
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                inc     hl
                push    hl
                ld      hl,(global112 + 0)
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,32
                ld      (hl),e
fornext127:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global112)  ; Get global I
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak126
                ld      hl,global112    ; Get global I
                call    __inc16
                jp      forloop125
forbreak126:    pop     de              ; Cleanup limit
; [482] 
; [483]     Q := L - P;
                ld      hl,global115 + 0
                push    hl
                ld      hl,(global113 + 0)
                ex      de,hl
                push    de
                ld      hl,(global114 + 0)
                ex      de,hl
                pop     hl
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [484]     if Q > 3 then Q := 3;
                ld      hl,(global115 + 0)
                ex      de,hl
                push    de
                ld      hl,3            ; Literal 3
                pop     de
                call    __int16_lt
                and     a
                jp      z,false128
                ld      hl,global115 + 0
                ld      de,3
                ld      (hl),e \ inc hl \ ld (hl),d
false128:
; [485] 
; [486]     for I := 1 to Q do TN[I - 1] := UpCase(S[P + I]);
                ld      hl,global112    ; Get global I
                ld      de,1
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      hl,(global115 + 0)
                ex      de,hl
                push    de
                push    de
                ld      hl,(global112)  ; Get global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak130
forloop129:
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,9
                add     hl,de
                push    hl
                ld      hl,(global112 + 0)
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      hl,(global114 + 0)
                ex      de,hl
                push    de
                ld      hl,(global112 + 0)
                ex      de,hl
                pop     hl
                add     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __UpCase57
                ex      de,hl
                pop     hl
                ld      (hl),e
fornext131:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global112)  ; Get global I
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak130
                ld      hl,global112    ; Get global I
                call    __inc16
                jp      forloop129
forbreak130:    pop     de              ; Cleanup limit
; [487]     for I := Q + 1 to 3 do TN[I - 1] := ' ';
                ld      hl,global112    ; Get global I
                push    hl
                ld      hl,(global115 + 0)
                inc     hl              ; Literal 1
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      de,3            ; Literal 3
                push    de
                push    de
                ld      hl,(global112)  ; Get global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak133
forloop132:
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,9
                add     hl,de
                push    hl
                ld      hl,(global112 + 0)
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,32
                ld      (hl),e
fornext134:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global112)  ; Get global I
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak133
                ld      hl,global112    ; Get global I
                call    __inc16
                jp      forloop132
forbreak133:    pop     de              ; Cleanup limit
; [488] (*
; [489]     Write(DR, ':');
; [490]     for I := 0 to 7 do Write(FN[I]);
; [491]     Write('.');
; [492]     for I := 0 to 2 do Write(TN[I]);
; [493]     WriteLn;
; [494] *)
; [495]   end;
                pop     bc
; [496] end;
exit116:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [497] 
; [498] procedure BlockErase(var F: FileControlBlock);
; [499] var
; [500]   A: Byte;
global136:      ds      1               ; Global A
; [501] begin
; var F(+6), A(@global136)
__BlockErase135:push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [502]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false138
                jp      exit137         ; Exit
false138:
; [503]   A := BDos(*Catch*)(19, Addr(F));
                ld      hl,global136 + 0
                push    hl
                ld      de,19           ; Literal 19
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e
; [504] end;
exit137:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [505] 
; [506] procedure BlockRename(var F: FileControlBlock; S: String);
; [507] var
; [508]   G: FileControlBlock;
; [509]   A: Byte;
global140:      ds      1               ; Global A
; [510] begin
; var F(+262), S(+6), G(-36), A(@global140)
__BlockRename139:push    ix             ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-38          ; Space
                add     hl,sp
                ld      sp,hl
; [511]   if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false142
                jp      exit141         ; Exit
false142:
; [512]   BlockAssign(G, S);
                ld      de,ix
                ld      hl,-36
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    __BlockAssign111
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [513]   if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false143
                jp      exit141         ; Exit
false143:
; [514]   Move(G, F.AL, 12);
                ld      de,ix
                ld      hl,-36
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,16           ; Literal 16
                add     hl,de
                push    hl
                ld      bc,12           ; Literal 12
                pop     de
                pop     hl
                call    __move
; [515]   BDosCatch(23, Addr(F));
                ld      de,23           ; Literal 23
                push    de
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __BDosCatch102
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [516] end;
exit141:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [517] 
; [518] procedure BlockReset(var F: FileControlBlock);
; [519] var
; [520]   A: Byte;
global145:      ds      1               ; Global A
; [521] begin
; var F(+6), A(@global145)
__BlockReset144:push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [522]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false147
                jp      exit146         ; Exit
false147:
; [523] 
; [524]   with F do
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [525]   begin
; [526]     EX := 0;
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,12
                add     hl,de
                ld      de,0
                ld      (hl),e
; [527]     S1 := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,13
                add     hl,de
                ld      de,0
                ld      (hl),e
; [528]     S2 := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,14
                add     hl,de
                ld      de,0
                ld      (hl),e
; [529]     RC := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,15
                add     hl,de
                ld      de,0
                ld      (hl),e
; [530]     CR := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,32
                add     hl,de
                ld      de,0
                ld      (hl),e
; [531] 
; [532]     RL := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,33
                add     hl,de
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [533]     RH := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,35
                add     hl,de
                ld      de,0
                ld      (hl),e
; [534]   end;
                pop     bc
; [535] 
; [536]   BDosCatch(15, Addr(F));
                ld      de,15           ; Literal 15
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __BDosCatch102
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [537] end;
exit146:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [538] 
; [539] procedure BlockRewrite(var F: FileControlBlock);
; [540] var
; [541]   A: Byte;
global149:      ds      1               ; Global A
; [542] begin
; var F(+6), A(@global149)
__BlockRewrite148:push    ix            ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [543]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false151
                jp      exit150         ; Exit
false151:
; [544] 
; [545]   with F do
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [546]   begin
; [547]     EX := 0;
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,12
                add     hl,de
                ld      de,0
                ld      (hl),e
; [548]     S1 := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,13
                add     hl,de
                ld      de,0
                ld      (hl),e
; [549]     S2 := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,14
                add     hl,de
                ld      de,0
                ld      (hl),e
; [550]     RC := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,15
                add     hl,de
                ld      de,0
                ld      (hl),e
; [551]     CR := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,32
                add     hl,de
                ld      de,0
                ld      (hl),e
; [552] 
; [553]     RL := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,33
                add     hl,de
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [554]     RH := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,35
                add     hl,de
                ld      de,0
                ld      (hl),e
; [555]   end;
                pop     bc
; [556] 
; [557]   A := BDos(*Catch*)(19, Addr(F));
                ld      hl,global149 + 0
                push    hl
                ld      de,19           ; Literal 19
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e
; [558]   BDosCatch(22, Addr(F));
                ld      de,22           ; Literal 22
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __BDosCatch102
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [559] end;
exit150:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [560] 
; [561] procedure BlockClose(var F: FileControlBlock);
; [562] begin
; var F(+6)
__BlockClose152:push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [563]   BDosCatch(16, Addr(F));
                ld      de,16           ; Literal 16
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __BDosCatch102
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [564] end;
exit153:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [565] 
; [566] function BlockFilePos(var F: FileControlBlock): Integer;
; [567] begin
; var BlockFilePos(@RESULT), F(+6)
__BlockFilePos154:push    ix            ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [568]   BlockFilePos := F.RL;
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [569] end;
exit155:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [570] 
; [571] function BlockFileSize(var F: FileControlBlock): Integer;
; [572] var
; [573]   I: Integer;
global157:      ds      2               ; Global I
; [574] begin
; var BlockFileSize(@RESULT), F(+6), I(@global157)
__BlockFileSize156:push    ix           ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [575]   with F do
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [576]   begin
; [577]     I := RL;
                push    de
                ld      hl,global157 + 0
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,33
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [578]     BDosCatch(35, Addr(F));
                ld      de,35           ; Literal 35
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __BDosCatch102
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [579]     if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false159
                jp      exit158         ; Exit
false159:
; [580]     BlockFileSize := RL;
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,33
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [581]     RL := I;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,33
                add     hl,de
                push    hl
                ld      hl,(global157 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [582]   end;
                pop     bc
; [583] end;
exit158:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [584] 
; [585] function BlockEof(var F: FileControlBlock): Boolean;
; [586] begin
; var BlockEof(@RESULT), F(+6)
__BlockEof160:  push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [587]   if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false162
                jp      exit161         ; Exit
false162:
; [588] 
; [589]   BlockEof := BlockFilePos(F) = BlockFileSize(F);
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __BlockFilePos154
; Post call cleanup 2 bytes
                pop     hl
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __BlockFileSize156
; Post call cleanup 2 bytes
                pop     hl
                pop     de              ; RelOp 9
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [590] end;
exit161:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [591] 
; [592] procedure BlockSeek(var F: FileControlBlock; I: Integer);
; [593] begin
; var F(+8), I(+6)
__BlockSeek163: push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [594]   if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false165
                jp      exit164         ; Exit
false165:
; [595] 
; [596]   F.RL := I;
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [597] end;
exit164:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [598] 
; [599] procedure BlockBlockRead(var F: FileControlBlock; var Buffer; Count: Integer; var Actual: Integer);
; [600] var
; [601]   DMA: Integer;
global167:      ds      2               ; Global DMA
; [602] begin
; var F(+12), Buffer(+10), Count(+8), Actual(+6), DMA(@global167)
__BlockBlockRead166:push    ix          ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [603]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false169
                jp      exit168         ; Exit
false169:
; [604] 
; [605]   DMA := Addr(Buffer);
                ld      hl,global167 + 0
                push    hl
                ld      de,ix
                ld      hl,10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [606]   Actual := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                ld      (hl),e \ inc hl \ ld (hl),d
; [607] 
; [608]   while Count > 0 do
while170:
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,0            ; Literal 0
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
; [609]   begin
                bit     0,l
                jp      z,false171
; [610]     BDosCatch(26, DMA);
                ld      de,26           ; Literal 26
                push    de
                ld      hl,(global167 + 0)
                ex      de,hl
                push    de
                call    __BDosCatch102
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [611]     BDosCatch(33, Addr(F));
                ld      de,33           ; Literal 33
                push    de
                ld      de,ix
                ld      hl,12
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __BDosCatch102
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [612]     if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false172
                jp      exit168         ; Exit
false172:
; [613] 
; [614]     Inc(F.RL);
                ld      de,ix
                ld      hl,12
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                call    __inc16
; [615]     Inc(DMA, 128);
                ld      hl,global167 + 0
                push    hl
                ld      bc,128          ; Literal 128
                pop     hl
                call    __inc16by
; [616]     Inc(Actual);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                call    __inc16
; [617]     Dec(Count);
                ld      de,ix
                ld      hl,8
                add     hl,de
                call    __dec16
; [618]   end;
                jp      while170
false171:
; [619] end;
exit168:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [620] 
; [621] procedure BlockBlockWrite(var F: FileControlBlock; var Buffer; Count: Integer; Actual: Integer);
; [622] var
; [623]   DMA: Integer;
global174:      ds      2               ; Global DMA
; [624] begin
; var F(+12), Buffer(+10), Count(+8), Actual(+6), DMA(@global174)
__BlockBlockWrite173:push    ix         ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [625]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false176
                jp      exit175         ; Exit
false176:
; [626] 
; [627]   DMA := Addr(Buffer);
                ld      hl,global174 + 0
                push    hl
                ld      de,ix
                ld      hl,10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [628]   (*Actual := 0;*)
; [629] 
; [630]   while Count > 0 do
while177:
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,0            ; Literal 0
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
; [631]   begin
                bit     0,l
                jp      z,false178
; [632]     BDosCatch(26, DMA);
                ld      de,26           ; Literal 26
                push    de
                ld      hl,(global174 + 0)
                ex      de,hl
                push    de
                call    __BDosCatch102
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [633]     BDosCatch(34, Addr(F));
                ld      de,34           ; Literal 34
                push    de
                ld      de,ix
                ld      hl,12
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __BDosCatch102
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [634]     if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false179
                jp      exit175         ; Exit
false179:
; [635] 
; [636]     Inc(F.RL);
                ld      de,ix
                ld      hl,12
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                call    __inc16
; [637]     Inc(DMA, 128);
                ld      hl,global174 + 0
                push    hl
                ld      bc,128          ; Literal 128
                pop     hl
                call    __inc16by
; [638] (*    Inc(Actual);*)
; [639]     Dec(Count);
                ld      de,ix
                ld      hl,8
                add     hl,de
                call    __dec16
; [640]   end;
                jp      while177
false178:
; [641] end;
exit175:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [642] 
; [643] (* --- Text file routines, use TextRec as representation -------------------- *)
; [644] 
; [645] procedure TextAssign(var T: TextRec; Name: String);
; [646] begin
; var T(+262), Name(+6)
__TextAssign180:push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [647]   BlockAssign(T.FCB, Name);
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    __BlockAssign111
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [648] end;
exit181:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [649] 
; [650] procedure TextReset(var T: TextRec);
; [651] var
; [652]   E: Integer;
global183:      ds      2               ; Global E
; [653] begin
; var T(+6), E(@global183)
__TextReset182: push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [654]   with T do
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [655]   begin
; [656]     BlockReset(FCB);
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __BlockReset144
; Post call cleanup 2 bytes
                pop     hl
; [657]     BlockBlockRead(FCB, DMA, 1, E);
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global183 + 0
                push    hl
                call    __BlockBlockRead166
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [658] 
; [659]     if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false185
                jp      exit184         ; Exit
false185:
; [660] 
; [661]     Readable := True;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      de,1
                ld      (hl),e
; [662]     Writable := False;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,37
                add     hl,de
                ld      de,0
                ld      (hl),e
; [663] 
; [664]     Offset := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [665]   end;
                pop     bc
; [666] end;
exit184:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [667] 
; [668] procedure TextRewrite(var T: TextRec);
; [669] begin
; var T(+6)
__TextRewrite186:push    ix             ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [670]   with T do
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [671]   begin
; [672]     BlockRewrite(FCB);
                push    de
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __BlockRewrite148
; Post call cleanup 2 bytes
                pop     hl
; [673] 
; [674]     if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false188
                jp      exit187         ; Exit
false188:
; [675] 
; [676]     Readable := False;
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      de,0
                ld      (hl),e
; [677]     Writable := True;
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,37
                add     hl,de
                ld      de,1
                ld      (hl),e
; [678] 
; [679]     Offset := 0;
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [680]   end;
                pop     bc
; [681] end;
exit187:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [682] 
; [683] procedure TextSeekEof(var T: TextRec);
; [684] var
; [685]   E: Integer;
global190:      ds      2               ; Global E
; [686] begin
; var T(+6), E(@global190)
__TextSeekEof189:push    ix             ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [687]   with T do
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [688]   begin
; [689]     BlockSeek(FCB, BlockFileSize(FCB) - 1);
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __BlockFileSize156
; Post call cleanup 2 bytes
                pop     hl
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                push    hl
                call    __BlockSeek163
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [690]     BlockBlockRead(FCB, DMA, 1, E);
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global190 + 0
                push    hl
                call    __BlockBlockRead166
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [691] 
; [692]     if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false192
                jp      exit191         ; Exit
false192:
; [693] 
; [694]     for Offset := 0 to 127 do
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      de,127          ; Literal 127
                push    de
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak194
forloop193:
; [695]       if DMA[Offset] = #26 then Exit;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                call    __int16_eq
                and     a
                jp      z,false196
                jp      exit191         ; Exit
false196:
fornext195:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak194
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                call    __inc16
                jp      forloop193
forbreak194:    pop     de              ; Cleanup limit
; [696]   end;
                pop     bc
; [697] end;
exit191:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [698] 
; [699] procedure TextAppend(var T: TextRec);
; [700] begin
; var T(+6)
__TextAppend197:push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [701]   with T do
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [702]   begin
; [703]     TextReset(T);
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __TextReset182
; Post call cleanup 2 bytes
                pop     hl
; [704]     TextSeekEof(T);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __TextSeekEof189
; Post call cleanup 2 bytes
                pop     hl
; [705] 
; [706]     if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false199
                jp      exit198         ; Exit
false199:
; [707] 
; [708]     Dec(FCB.RL);
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                call    __dec16
; [709] 
; [710]     Readable := False;
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      de,0
                ld      (hl),e
; [711]     Writable := True;
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,37
                add     hl,de
                ld      de,1
                ld      (hl),e
; [712]   end;
                pop     bc
; [713] end;
exit198:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [714] 
; [715] procedure TextReadChar(var T: TextRec; var C: Char);
; [716] var
; [717]   E: Integer;
global201:      ds      2               ; Global E
; [718] begin
; var T(+8), C(+6), E(@global201)
__TextReadChar200:push    ix            ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [719]   with T do
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [720]   begin
; [721]     C := DMA[Offset];
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [722]     if C <> #26 then
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                call    __int16_neq
                ld      h,0
                ld      l,a
; [723]     begin
                bit     0,l
                jp      z,false203
; [724]       Inc(Offset);
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                call    __inc16
; [725]       if Offset = 128 then
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,128          ; Literal 128
                call    __int16_eq
                ld      h,0
                ld      l,a
; [726]       begin
                bit     0,l
                jp      z,false204
; [727]         BlockBlockRead(FCB, DMA, 1, E);
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global201 + 0
                push    hl
                call    __BlockBlockRead166
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [728]         if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false205
                jp      exit202         ; Exit
false205:
; [729]         Offset := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [730]       end;
false204:
; [731]     end;
false203:
; [732]   end;
                pop     bc
; [733] end;
exit202:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [734] 
; [735] procedure TextSeekEoln(var T: TextRec);
; [736] var
; [737]   C: Char;
global207:      ds      1               ; Global C
; [738] begin
; var T(+6), C(@global207)
__TextSeekEoln206:push    ix            ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [739]   with T do
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [740]   begin
; [741]     while DMA[Offset] <> #13 do
                push    de
while209:
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,13           ; Literal 13
                call    __int16_neq
                ld      h,0
                ld      l,a
; [742]     begin
                bit     0,l
                jp      z,false210
; [743]       TextReadChar(T, C);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,global207 + 0
                push    hl
                call    __TextReadChar200
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [744]       if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false211
                jp      exit208         ; Exit
false211:
; [745]     end;
                jp      while209
false210:
; [746]   end;
                pop     bc
; [747] end;
exit208:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [748] 
; [749] procedure TextReadStr(var T: TextRec; var S: String);
; [750] var
; [751]   C: Char;
global213:      ds      1               ; Global C
; [752] begin
; var T(+8), S(+6), C(@global213)
__TextReadStr212:push    ix             ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [753]   S := '';
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,string84
                pop     de
                ld      a,255
                call    __movestr
; [754] 
; [755]   while Length(S) < 255 do
while215:
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                ld      de,255          ; Literal 255
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
; [756]   begin
                bit     0,l
                jp      z,false216
; [757]     TextReadChar(T, C);
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,global213 + 0
                push    hl
                call    __TextReadChar200
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [758]     if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false217
                jp      exit214         ; Exit
false217:
; [759] 
; [760]     if C = #10 then Break;
                ld      hl,global213 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,10           ; Literal 10
                call    __int16_eq
                and     a
                jp      z,false218
                jp      false216        ; Break
false218:
; [761]     if C = #26 then Break;
                ld      hl,global213 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                call    __int16_eq
                and     a
                jp      z,false219
                jp      false216        ; Break
false219:
; [762] 
; [763]     if C >= ' ' then S := S + C;
                ld      hl,global213 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,32           ; Literal 32
                call    __int16_geq
                and     a
                jp      z,false220
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                call    __loadstr
                ld      hl,global213 + 0
                ld      d,0
                ld      e,(hl)
                call    __char2str
                call    __stradd
                call    __rmstr
                ld      a,255
                call    __storestr
false220:
; [764]   end;
                jp      while215
false216:
; [765] end;
exit214:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [766] 
; [767] procedure TextReadWord(var T: TextRec; var S: String);
; [768] var
; [769]   C: Char;
global222:      ds      1               ; Global C
; [770] begin
; var T(+8), S(+6), C(@global222)
__TextReadWord221:push    ix            ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [771]   S := '';
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,string84
                pop     de
                ld      a,255
                call    __movestr
; [772] 
; [773]   while Length(S) < 255 do
while224:
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                ld      de,255          ; Literal 255
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
; [774]   begin
                bit     0,l
                jp      z,false225
; [775]     TextReadChar(T, C);
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,global222 + 0
                push    hl
                call    __TextReadChar200
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [776]     if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false226
                jp      exit223         ; Exit
false226:
; [777] 
; [778]     if C > ' ' then S := S + C else Break;
                ld      hl,global222 + 0
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,32           ; Literal 32
                pop     de
                call    __int16_lt
                and     a
                jp      z,false227
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                call    __loadstr
                ld      hl,global222 + 0
                ld      d,0
                ld      e,(hl)
                call    __char2str
                call    __stradd
                call    __rmstr
                ld      a,255
                call    __storestr
                jp      endif228
false227:
                jp      false225        ; Break
endif228:
; [779]   end;
                jp      while224
false225:
; [780] end;
exit223:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [781] 
; [782] procedure TextReadInt(var T: TextRec; var I: Integer);
; [783] var
; [784]   S: String;
; [785]   E: Integer;
global230:      ds      2               ; Global E
; [786] begin
; var T(+8), I(+6), S(-256), E(@global230)
__TextReadInt229:push    ix             ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-258         ; Space
                add     hl,sp
                ld      sp,hl
; [787]   TextReadWord(T, S);
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-256
                add     hl,de
                push    hl
                call    __TextReadWord221
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [788]   if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false232
                jp      exit231         ; Exit
false232:
; [789]   Val(S, I, E);
                ld      de,ix
                ld      hl,-256
                add     hl,de
                call    __loadstr
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,global230 + 0
                push    hl
                call    __val_int
; [790] end;
exit231:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [791] 
; [792] procedure TextReadFloat(var T: TextRec; var R: Real);
; [793] var
; [794]   S: String;
; [795]   E: Integer;
global234:      ds      2               ; Global E
; [796] begin
; var T(+8), R(+6), S(-256), E(@global234)
__TextReadFloat233:push    ix           ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-258         ; Space
                add     hl,sp
                ld      sp,hl
; [797]   TextReadWord(T, S);
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-256
                add     hl,de
                push    hl
                call    __TextReadWord221
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [798]   if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false236
                jp      exit235         ; Exit
false236:
; [799]   Val(S, R, E);
                ld      de,ix
                ld      hl,-256
                add     hl,de
                call    __loadstr
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,global234 + 0
                push    hl
                call    __val_float
; [800] end;
exit235:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [801] 
; [802] procedure TextWriteChar(var T: TextRec; C: Char);
; [803] var
; [804]   E: Integer;
global238:      ds      2               ; Global E
; [805] begin
; var T(+8), C(+6), E(@global238)
__TextWriteChar237:push    ix           ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [806]   with T do
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [807]   begin
; [808]     DMA[Offset] := C;
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [809]     Inc(Offset);
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                call    __inc16
; [810]     if Offset = 128 then
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,128          ; Literal 128
                call    __int16_eq
                ld      h,0
                ld      l,a
; [811]     begin
                bit     0,l
                jp      z,false240
; [812]       BlockBlockWrite(FCB, DMA, 1, E);
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,(global238 + 0)
                ex      de,hl
                push    de
                call    __BlockBlockWrite173
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [813]       if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false241
                jp      exit239         ; Exit
false241:
; [814]       Offset := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [815]     end;
false240:
; [816]   end;
                pop     bc
; [817] end;
exit239:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [818] 
; [819] procedure TextFlush(var T: TextRec);
; [820] var
; [821]   E: Integer;
global243:      ds      2               ; Global E
; [822] begin
; var T(+6), E(@global243)
__TextFlush242: push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [823]   with T do
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [824]   begin
; [825]     (* FIXME !!! *)
; [826]     TextWriteChar(T, #26);
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,26           ; Literal 26
                push    de
                call    __TextWriteChar237
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [827] 
; [828]     if Offset <> 0 then
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                ld      h,0
                ld      l,a
; [829]       BlockBlockWrite(FCB, DMA, 1, E);
                bit     0,l
                jp      z,false245
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,(global243 + 0)
                ex      de,hl
                push    de
                call    __BlockBlockWrite173
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
false245:
; [830] 
; [831]     if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false246
                jp      exit244         ; Exit
false246:
; [832] 
; [833]     Readable := False;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      de,0
                ld      (hl),e
; [834]     Writable := False;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,37
                add     hl,de
                ld      de,0
                ld      (hl),e
; [835]   end;
                pop     bc
; [836] end;
exit244:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [837] 
; [838] procedure TextClose(var T: TextRec);
; [839] var
; [840]   E: Integer;
global248:      ds      2               ; Global E
; [841] begin
; var T(+6), E(@global248)
__TextClose247: push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [842]   with T do
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [843]   begin
; [844]     if Writable then TextFlush(T);
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,37
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                bit     0,l
                jp      z,false250
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __TextFlush242
; Post call cleanup 2 bytes
                pop     hl
false250:
; [845] 
; [846]     BlockClose(FCB);
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __BlockClose152
; Post call cleanup 2 bytes
                pop     hl
; [847] 
; [848]     if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false251
                jp      exit249         ; Exit
false251:
; [849] 
; [850]     Readable := False;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      de,0
                ld      (hl),e
; [851]     Writable := False;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,37
                add     hl,de
                ld      de,0
                ld      (hl),e
; [852]   end;
                pop     bc
; [853] end;
exit249:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [854] 
; [855] procedure TextWriteStr(var T: TextRec; S: String);
; [856] var
; [857]   I: Byte;
global253:      ds      1               ; Global I
; [858] begin
; var T(+262), S(+6), I(@global253)
__TextWriteStr252:push    ix            ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [859]   for I := 1 to Length(S) do
                push    hl
                ld      hl,global253    ; Get global I
                ld      de,1
                ld      (hl),e
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      hl,global253    ; Get global I
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak256
forloop255:
; [860]   begin
; [861]     TextWriteChar(T, S[I]);
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      hl,global253 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                call    __TextWriteChar237
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [862]     if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false258
                jp      exit254         ; Exit
false258:
; [863]   end;
fornext257:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,global253    ; Get global I
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak256
                ld      hl,global253    ; Get global I
                inc     (hl)
                jp      forloop255
forbreak256:    pop     de              ; Cleanup limit
; [864] end;
exit254:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [865] 
; [866] procedure TextWriteEoln(var T: TextRec);
; [867] begin
; var T(+6)
__TextWriteEoln259:push    ix           ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [868]   TextWriteChar(T, #13);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,13           ; Literal 13
                push    de
                call    __TextWriteChar237
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [869]   TextWriteChar(T, #10);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,10           ; Literal 10
                push    de
                call    __TextWriteChar237
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [870] end;
exit260:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [871] 
; [872] function TextEoln(var T: TextRec): Boolean;
; [873] begin
; var TextEoln(@RESULT), T(+6)
__TextEoln261:  push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [874]   with T do
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [875]     TextEoln := DMA[Offset] = #13;
                push    de
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                push    hl
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,13           ; Literal 13
                call    __int16_eq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
                pop     bc
; [876] end;        
exit262:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [877] 
; [878] function TextEof(var T: TextRec): Boolean;
; [879] begin
; var TextEof(@RESULT), T(+6)
__TextEof263:   push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [880]   with T do
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [881]     TextEof := DMA[Offset] = #26;
                push    de
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                push    hl
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                call    __int16_eq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
                pop     bc
; [882] end;        
exit264:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [883] 
; [884] (* --- Typed file routines, use FileRec as representation ------------------- *)
; [885] 
; [886] procedure FileAssign(var F: FileRec; Name: String; Size: Integer);
; [887] begin
; var F(+264), Name(+8), Size(+6)
__FileAssign265:push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [888]   if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false267
                jp      exit266         ; Exit
false267:
; [889] 
; [890]   with F do
                ld      de,ix
                ld      hl,264
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [891]   begin
; [892]     BlockAssign(FCB, Name);    
                push    de
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,8
                add     hl,de
                call    __loadstr
                call    __BlockAssign111
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [893]     CompSize := Size;
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [894]   end;
                pop     bc
; [895] end;
exit266:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [896] 
; [897] procedure FileReset(var F: FileRec);
; [898] var
; [899]   E: Integer;
global269:      ds      2               ; Global E
; [900] begin
; var F(+6), E(@global269)
__FileReset268: push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [901]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false271
                jp      exit270         ; Exit
false271:
; [902] 
; [903]   with F do
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [904]   begin
; [905]     BlockReset(FCB);
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __BlockReset144
; Post call cleanup 2 bytes
                pop     hl
; [906]     BlockBlockRead(FCB, DMA, 1, E);
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global269 + 0
                push    hl
                call    __BlockBlockRead166
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [907] 
; [908]     if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false272
                jp      exit270         ; Exit
false272:
; [909] 
; [910]     if CompSize <> HdrSize then
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,47
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
; [911]     begin
                bit     0,l
                jp      z,false273
; [912]       WriteLn('Invalid file type');
                ld      hl,string274
                call    __puts
                call    __newline
; [913]       Halt;
                jp      __done
; [914]     end;
false273:
; [915]   
; [916]     CompCount := HdrCount;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [917]     CompIndex := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [918] 
; [919]     Offset := 4;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,4
                ld      (hl),e \ inc hl \ ld (hl),d
; [920]     Modified := False;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                ld      de,0
                ld      (hl),e
; [921] 
; [922]     (*WriteLn('Opened existing file, size=', CompSize, ' count=', CompCount);
; [923]     ReadLn;*)
; [924]   end;
                pop     bc
; [925] end;
exit270:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [926] 
; [927] procedure FileRewrite(var F: FileRec);
; [928] var
; [929]   E: Integer;
global276:      ds      2               ; Global E
; [930] begin
; var F(+6), E(@global276)
__FileRewrite275:push    ix             ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [931]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false278
                jp      exit277         ; Exit
false278:
; [932] 
; [933]   with F do
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [934]   begin
; [935]     BlockRewrite(FCB);
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __BlockRewrite148
; Post call cleanup 2 bytes
                pop     hl
; [936] 
; [937]     if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false279
                jp      exit277         ; Exit
false279:
; [938] 
; [939]     HdrSize := CompSize;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,47
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [940]     HdrCount := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [941] 
; [942]     CompCount := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [943]     CompIndex := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [944] 
; [945]     Offset := 4;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,4
                ld      (hl),e \ inc hl \ ld (hl),d
; [946]     Modified := True;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                ld      de,1
                ld      (hl),e
; [947] 
; [948]     BlockBlockWrite(FCB, DMA, 1, E); (* TODO Delay this until Flush/Close? *)
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,(global276 + 0)
                ex      de,hl
                push    de
                call    __BlockBlockWrite173
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [949] 
; [950]     if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false280
                jp      exit277         ; Exit
false280:
; [951] 
; [952]     (*WriteLn('Created new file, size=', CompSize, ' count=', CompCount);*)
; [953]   end;
                pop     bc
; [954] end;
exit277:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [955] 
; [956] function FileFileSize(var F: FileRec): Integer;
; [957] begin
; var FileFileSize(@RESULT), F(+6)
__FileFileSize281:push    ix            ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [958]   if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false283
                jp      exit282         ; Exit
false283:
; [959] 
; [960]   FileFileSize := F.CompCount;
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38           ; Literal 38
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [961] end;
exit282:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [962] 
; [963] function FileFilePos(var F: FileRec): Integer;
; [964] begin
; var FileFilePos(@RESULT), F(+6)
__FileFilePos284:push    ix             ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [965]   if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false286
                jp      exit285         ; Exit
false286:
; [966] 
; [967]   FileFilePos := F.CompIndex;
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,40           ; Literal 40
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [968] end;
exit285:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [969] 
; [970] function FileEof(var F: FileRec): Boolean;
; [971] begin
; var FileEof(@RESULT), F(+6)
__FileEof287:   push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [972]   if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false289
                jp      exit288         ; Exit
false289:
; [973] 
; [974]   with F do
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [975]     FileEof := CompIndex = CompCount;
                push    de
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
                pop     bc
; [976] end;
exit288:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [977] 
; [978] procedure FileFlush(var F: FileRec);
; [979] var
; [980]   E: Integer;
global291:      ds      2               ; Global E
; [981] begin
; var F(+6), E(@global291)
__FileFlush290: push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [982]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false293
                jp      exit292         ; Exit
false293:
; [983] 
; [984]   with F do
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [985]   begin
; [986]     if Modified then
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                ld      d,0
                ld      e,(hl)
; [987]     begin
                ex      de,hl
                bit     0,l
                jp      z,false294
; [988]       Dec(FCB.RL);
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                call    __dec16
; [989]       BlockBlockWrite(FCB, DMA, 1, E);
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,(global291 + 0)
                ex      de,hl
                push    de
                call    __BlockBlockWrite173
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [990]       if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false295
                jp      exit292         ; Exit
false295:
; [991]       Modified := False;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                ld      de,0
                ld      (hl),e
; [992]     end;
false294:
; [993]   end;
                pop     bc
; [994] end;
exit292:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [995] 
; [996] procedure FileSeek(var F: FileRec; I: Integer);
; [997] var
; [998]   P, S: Real;
global297:      ds      6               ; Global P
global298:      ds      6               ; Global S
; [999]   E: Integer;
global299:      ds      2               ; Global E
; [1000] begin
; var F(+8), I(+6), P(@global297), S(@global298), E(@global299)
__FileSeek296:  push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-14          ; Space
                add     hl,sp
                ld      sp,hl
; [1001]   if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false301
                jp      exit300         ; Exit
false301:
; [1002] 
; [1003]   with F do
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [1004]   begin
; [1005]     FileFlush(F);
                push    de
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __FileFlush290
; Post call cleanup 2 bytes
                pop     hl
; [1006] 
; [1007]     if I > CompCount then
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-16
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
; [1008]     begin
                bit     0,l
                jp      z,false302
; [1009]       WriteLn('*** ', I, ' > ', CompCount);
                ld      hl,string303
                call    __puts
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                call    __putn
                ld      hl,string304
                call    __puts
                ld      de,ix
                ld      hl,-16
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                call    __putn
                call    __newline
; [1010]       Halt;
                jp      __done
; [1011]     end;
false302:
; [1012] 
; [1013]     if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false305
                jp      exit300         ; Exit
false305:
; [1014] 
; [1015]     P := 4.0 + I * 1.0 * CompSize;    (* Should we use Real here?    *)
                ld      hl,global297 + 0
                push    hl
                constfp 0x0083,0x0000,0x0000
                pushfp
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                constfp 0x0081,0x0000,0x0000
                exx
                pop     hl
                exx
                pushfp
                exx
                call    FLOAT
                exx
                popfp
                exx
                pushfp
                exx
                exx
                popfp
                call    FPMUL
                pushfp
                ld      de,ix
                ld      hl,-16
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                call    FLOAT
                exx
                popfp
                call    FPMUL
                exx
                popfp
                call    FPADD
                exx
                pop     hl
                call    __storefp
; [1016]     S := Int(P / 128);
                ld      hl,global298 + 0
                push    hl
                ld      hl,global297 + 0
                call    __loadfp
                pushfp
                ld      hl,128          ; Literal 128
                call    FLOAT
                exx
                popfp
                call    FPDIV
                call    INT
                exx
                pop     hl
                call    __storefp
; [1017]     (* WriteLn('Seeking to index ', I, ' offset ', P, ' sector ', S);*)
; [1018]     BlockSeek(FCB, Trunc(S));  (* Why does div not work here? *)
                ld      de,ix
                ld      hl,-16
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,global298 + 0
                call    __loadfp
                call    FIX
                push    hl
                call    __BlockSeek163
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [1019]     if I < CompCount then
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-16
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
; [1020]       BlockBlockRead(FCB, DMA, 1, E)
                bit     0,l
                jp      z,false306
                ld      de,ix
                ld      hl,-16
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-16
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global299 + 0
; [1021]     else
                push    hl
                call    __BlockBlockRead166
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
                jp      endif307
false306:
; [1022]       Inc(FCB.RL);
                ld      de,ix
                ld      hl,-16
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                call    __inc16
endif307:
; [1023] 
; [1024]     if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false308
                jp      exit300         ; Exit
false308:
; [1025] 
; [1026]     Offset := Trunc(P - 128 * S); (* Abs(P mod 128); *)
                ld      de,ix
                ld      hl,-16
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                push    hl
                ld      hl,global297 + 0
                call    __loadfp
                pushfp
                ld      de,128          ; Literal 128
                push    de
                ld      hl,global298 + 0
                call    __loadfp
                exx
                pop     hl
                exx
                pushfp
                exx
                call    FLOAT
                exx
                popfp
                exx
                pushfp
                exx
                exx
                popfp
                call    FPMUL
                exx
                popfp
                call    FPSUB
                call    FIX
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [1027] 
; [1028]     CompIndex := I;
                ld      de,ix
                ld      hl,-16
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [1029]   end;
                pop     bc
; [1030] end;
exit300:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [1031] 
; [1032] procedure FileRead(var F: FileRec; var Comp);
; [1033] var
; [1034]   Address, Need, Avail, Bytes, E: Integer;
global310:      ds      2               ; Global Address
global311:      ds      2               ; Global Need
global312:      ds      2               ; Global Avail
global313:      ds      2               ; Global Bytes
global314:      ds      2               ; Global E
; [1035]   (*Mem: array[0..65535] of Byte absolute 0;*)
; [1036]   P: ^Byte absolute Address;
; [1037] begin
; var F(+8), Comp(+6), Address(@global310), Need(@global311), Avail(@global312), Bytes(@global313), E(@global314), P(@global310)
__FileRead309:  push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-12          ; Space
                add     hl,sp
                ld      sp,hl
; [1038]   if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false316
                jp      exit315         ; Exit
false316:
; [1039] 
; [1040]   (* WriteLn('Read entry #', FileFilePos(F)); *)
; [1041] 
; [1042]   with F do
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [1043]   begin
; [1044]     Address := Addr(Comp);
                push    de
                ld      hl,global310 + 0
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [1045]     Need := CompSize;
                ld      hl,global311 + 0
                push    hl
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [1046] 
; [1047]     while Need <> 0 do
while317:
                ld      hl,(global311 + 0)
                ld      de,0            ; Literal 0
                call    __int16_neq
                ld      h,0
                ld      l,a
; [1048]     begin
                bit     0,l
                jp      z,false318
; [1049]       Avail := 128 - Offset;
                ld      hl,global312 + 0
                push    hl
                ld      de,128          ; Literal 128
                push    de
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [1050]       if Avail >= Need then
                ld      hl,(global312 + 0)
                ex      de,hl
                push    de
                ld      hl,(global311 + 0)
                ex      de,hl
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
; [1051]         Bytes := Need
                bit     0,l
                jp      z,false319
                ld      hl,global313 + 0
; [1052]       else
                push    hl
                ld      hl,(global311 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
                jp      endif320
false319:
; [1053]         Bytes := Avail;
                ld      hl,global313 + 0
                push    hl
                ld      hl,(global312 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
endif320:
; [1054] 
; [1055]       Move(DMA[Offset], P^, Bytes); (* Hmm... feels like a hack. *)
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      hl,global310 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(global313 + 0)
                ex      de,hl
                ld      bc,de
                pop     de
                pop     hl
                call    __move
; [1056]       Inc(Address, Bytes);
                ld      hl,global310 + 0
                push    hl
                ld      hl,(global313 + 0)
                ex      de,hl
                ld      bc,de
                pop     hl
                call    __inc16by
; [1057]       Inc(Offset, Bytes);
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                push    hl
                ld      hl,(global313 + 0)
                ex      de,hl
                ld      bc,de
                pop     hl
                call    __inc16by
; [1058]       Dec(Need, Bytes);
                ld      hl,global311 + 0
                push    hl
                ld      hl,(global313 + 0)
                ex      de,hl
                ld      bc,de
                pop     hl
                call    __dec16by
; [1059] 
; [1060]       if Offset = 128 then
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,128          ; Literal 128
                call    __int16_eq
                ld      h,0
                ld      l,a
; [1061]       begin
                bit     0,l
                jp      z,false321
; [1062]         FileFlush(F);
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __FileFlush290
; Post call cleanup 2 bytes
                pop     hl
; [1063]         if FileEof(F) then
                ld      de,0            ; Literal 0
                push    de
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __FileEof287
; Post call cleanup 2 bytes
                pop     hl
; [1064]           Inc(FCB.RL)
                pop     hl
                bit     0,l
                jp      z,false322
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                call    __inc16
; [1065]         else
                jp      endif323
false322:
; [1066]           BlockBlockRead(FCB, DMA, 1, E);
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global314 + 0
                push    hl
                call    __BlockBlockRead166
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
endif323:
; [1067]         if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false324
                jp      exit315         ; Exit
false324:
; [1068]         Offset := 0;
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [1069]       end;
false321:
; [1070]     end;
                jp      while317
false318:
; [1071] 
; [1072]     Inc(CompIndex);
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                call    __inc16
; [1073]   end;
                pop     bc
; [1074] end;
exit315:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [1075] 
; [1076] procedure FileWrite(var F: FileRec; var Comp);
; [1077] var
; [1078]   Address, Need, Avail, Bytes, E: Integer;
global326:      ds      2               ; Global Address
global327:      ds      2               ; Global Need
global328:      ds      2               ; Global Avail
global329:      ds      2               ; Global Bytes
global330:      ds      2               ; Global E
; [1079]   (*Mem: array[0..65535] of Byte absolute 0;*)
; [1080]   P: ^Byte absolute Address;
; [1081] begin
; var F(+8), Comp(+6), Address(@global326), Need(@global327), Avail(@global328), Bytes(@global329), E(@global330), P(@global326)
__FileWrite325: push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-12          ; Space
                add     hl,sp
                ld      sp,hl
; [1082]   if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false332
                jp      exit331         ; Exit
false332:
; [1083] 
; [1084]   (* WriteLn('Wrote entry #', FileFilePos(F)); *)
; [1085] 
; [1086]   with F do
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [1087]   begin
; [1088]     Address := Addr(Comp);
                push    de
                ld      hl,global326 + 0
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [1089]     Need := CompSize;
                ld      hl,global327 + 0
                push    hl
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [1090] 
; [1091]     while Need <> 0 do
while333:
                ld      hl,(global327 + 0)
                ld      de,0            ; Literal 0
                call    __int16_neq
                ld      h,0
                ld      l,a
; [1092]     begin
                bit     0,l
                jp      z,false334
; [1093]       Avail := 128 - Offset;
                ld      hl,global328 + 0
                push    hl
                ld      de,128          ; Literal 128
                push    de
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [1094]       if Avail >= Need then
                ld      hl,(global328 + 0)
                ex      de,hl
                push    de
                ld      hl,(global327 + 0)
                ex      de,hl
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
; [1095]         Bytes := Need
                bit     0,l
                jp      z,false335
                ld      hl,global329 + 0
; [1096]       else
                push    hl
                ld      hl,(global327 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
                jp      endif336
false335:
; [1097]         Bytes := Avail;
                ld      hl,global329 + 0
                push    hl
                ld      hl,(global328 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
endif336:
; [1098] 
; [1099]       Move(P^, DMA[Offset], Bytes); (* Hmm... feels like a hack. *)
                ld      hl,global326 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      hl,(global329 + 0)
                ex      de,hl
                ld      bc,de
                pop     de
                pop     hl
                call    __move
; [1100]       Inc(Address, Bytes);
                ld      hl,global326 + 0
                push    hl
                ld      hl,(global329 + 0)
                ex      de,hl
                ld      bc,de
                pop     hl
                call    __inc16by
; [1101]       Inc(Offset, Bytes);
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                push    hl
                ld      hl,(global329 + 0)
                ex      de,hl
                ld      bc,de
                pop     hl
                call    __inc16by
; [1102]       Dec(Need, Bytes);
                ld      hl,global327 + 0
                push    hl
                ld      hl,(global329 + 0)
                ex      de,hl
                ld      bc,de
                pop     hl
                call    __dec16by
; [1103]       Modified := True;
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                ld      de,1
                ld      (hl),e
; [1104] 
; [1105]       if Offset = 128 then
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,128          ; Literal 128
                call    __int16_eq
                ld      h,0
                ld      l,a
; [1106]       begin
                bit     0,l
                jp      z,false337
; [1107]         FileFlush(F);
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __FileFlush290
; Post call cleanup 2 bytes
                pop     hl
; [1108]         if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false338
                jp      exit331         ; Exit
false338:
; [1109] 
; [1110]         if FileEof(F) then
                ld      de,0            ; Literal 0
                push    de
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __FileEof287
; Post call cleanup 2 bytes
                pop     hl
; [1111]           Inc(FCB.RL)
                pop     hl
                bit     0,l
                jp      z,false339
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                call    __inc16
; [1112]         else
                jp      endif340
false339:
; [1113]           BlockBlockRead(FCB, DMA, 1, E);
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global330 + 0
                push    hl
                call    __BlockBlockRead166
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
endif340:
; [1114] 
; [1115]         Offset := 0;
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [1116]       end;
false337:
; [1117]     end;
                jp      while333
false334:
; [1118] 
; [1119]     if CompIndex = CompCount then Inc(CompCount);
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                call    __int16_eq
                and     a
                jp      z,false341
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                call    __inc16
false341:
; [1120]     Inc(CompIndex);
                ld      de,ix
                ld      hl,-14
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                call    __inc16
; [1121]   end;
                pop     bc
; [1122] end;
exit331:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [1123] 
; [1124] procedure FileClose(var F: FileRec);
; [1125] var
; [1126]   E: Integer;
global343:      ds      2               ; Global E
; [1127] begin
; var F(+6), E(@global343)
__FileClose342: push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [1128]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false345
                jp      exit344         ; Exit
false345:
; [1129]   
; [1130]   with F do
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [1131]   begin
; [1132]     FileFlush(F);
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __FileFlush290
; Post call cleanup 2 bytes
                pop     hl
; [1133] 
; [1134]     BlockSeek(FCB, 0);
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,0            ; Literal 0
                push    de
                call    __BlockSeek163
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [1135]     BlockBlockRead(FCB, DMA, 1, E);
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global343 + 0
                push    hl
                call    __BlockBlockRead166
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [1136] 
; [1137]     if LastError <> 0 then Exit;
                ld      hl,const99 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                and     a
                jp      z,false346
                jp      exit344         ; Exit
false346:
; [1138] 
; [1139]     HdrCount := CompCount;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [1140] 
; [1141]     (*WriteLn('File closing: ', CompCount, '*', CompCount, ' --- ', HdrCount, '*', HdrSize);
; [1142]     ReadLn; *)
; [1143] 
; [1144]     BlockSeek(FCB, 0);
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,0            ; Literal 0
                push    de
                call    __BlockSeek163
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [1145]     BlockBlockWrite(FCB, DMA, 1, E);
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,(global343 + 0)
                ex      de,hl
                push    de
                call    __BlockBlockWrite173
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [1146]     BlockClose(FCB);
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    __BlockClose152
; Post call cleanup 2 bytes
                pop     hl
; [1147]   end;
                pop     bc
; [1148]   (* WriteLn('Closed file'); *)
; [1149] end;
exit344:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [1150] 
; [1151] end.
; [0] program MicroCalc;
; [1] {
; [2]     MICROCALC DEMONSTRATION PROGRAM  Version 1.00A
; [3] 
; [4]   This program is Copyrighted by Borland International, Inc.
; [5]   1983, 1984, 1985 and is hereby donated to the public domain for
; [6]   non-commercial use only.  Dot commands are for the program
; [7]   lister:   LISTT.PAS  (available with  our TURBO TUTOR):
; [8] 
; [9]       .PA, .CP20, etc...
; [10] 
; [11]   INSTRUCTIONS
; [12]     1.  Compile this program using the TURBO.COM compiler.
; [13]         a.  Use the O command from the main menu to select Options.
; [14]         b.  Select the C option to generate a .COM file.
; [15]         c.  Select the Q option to Quit the Options menu.
; [16]         d.  Select the M option to specify the Main file
; [17]         e.  Type "MC" and hit <RETURN>
; [18]         f.  Type C to compile the program to disk
; [19]         g.  Type R to run the program
; [20] 
; [21]     2.  Exit the program by typing: /Q
; [22] }
; [23] 
; [24] {$R-,U-,V-,X-,A+,C-}
; [25] 
; [26] 
; [27] const
; [28]   FXMax: Char  = 'G';  { Maximum number of columns                   }
const347:
                db      "G"
; [29]   FYMax        = 21;   { Maximum number of lines                     }
; [30] 
; [31] type
; [32]   Anystring   = string[255];
; [33]   ScreenIndex = 'A'..'G';
; [34]   Attributes  = (Constant,Formula,Txt,OverWritten,Locked,Calculated);
enumlit348:
                dw      string349,string350,string351,string352,string353,string354,0
; [35] 
; [36] { The spreadsheet is made out of Cells every Cell is defined as      }
; [37] { the following record:                                              }
; [38] 
; [39]   CellRec    = record
; [40]     CellStatus: set of Attributes; { Status of cell (see type def.)  }
; [41]     Contents:   String[70];        { Contains a formula or some text }
; [42]     Value:      Real;              { Last calculated cell value      }
; [43]     DEC,FW:     0..20;             { Decimals and Cell Whith         }
; [44]   end;
; [45] 
; [46]   Cells      =  array[ScreenIndex,1..FYMax] of CellRec;
; [47] 
; [48] const
; [49]   XPOS: array[ScreenIndex] of integer = (3,14,25,36,47,58,68);
const355:
                dw      3,14,25,36,47,58,68
; [50] 
; [51] var
; [52]   Screen:        Cells;             { Definition of the spread sheet }
global356:      ds      16317           ; Global Screen
; [53]   FX:            ScreenIndex;       { Culumn of current cell         }
global357:      ds      1               ; Global FX
; [54]   FY:            Integer;           { Line of current cell           }
global358:      ds      2               ; Global FY
; [55]   Ch:            Char;              { Last read character            }
global359:      ds      1               ; Global Ch
; [56]   MCFile:        file of CellRec;   { File to store sheets in        }
global360:      ds